\section{Introduction}

Public blockchains supporting smart contracts, such as Ethereum and its Layer-2 rollups~\cite{ethereum,base,arbitrum,polygon,bsc}, fundamentally operate as replicated state machines. From a data management perspective, each node functions as a deterministic transaction processor that must handle two distinct workloads, namely the real-time processing of incoming transactions and the re-execution of historical transactions to verify global state transitions. As network throughput and contract complexity continue to increase, execution efficiency emerges as a primary scalability bottleneck for both scenarios.

Achieving meaningful acceleration on modern, hyper-optimized execution engines~\cite{revm,evmone} requires overcoming three fundamental tensions. \textbf{First}, optimization conflicts with semantic preservation. Standard compiler optimizations such as instruction reordering inherently alter the observable execution trace, violating the strict gas accounting rules that underpin economic consensus~\cite{revmc,monad,evmjit,bnbjit}. A single gas discrepancy can cause nodes to diverge on state validity. Moreover, Just-In-Time (JIT) compilation introduces security vulnerabilities where maliciously crafted contracts exploit compilation overhead to mount denial-of-service attacks~\cite{JITBomb}. These constraints demand that any viable acceleration strategy preserve gas semantics by construction. \textbf{Second}, instrumentation overhead conflicts with execution latency. On sub-microsecond engines such as Revm~\cite{revm}, the cost of synchronous tracing frequently exceeds execution latency itself, creating what we term the \textit{Performance Paradox}~\cite{forerunner,seer}. Similarly, operation-level concurrent execution incurs synchronization costs that outweigh parallel gains~\cite{parallelEvm,evmTracer}. Any optimization blocking the critical path risks performance regression. \textbf{Third}, artifact granularity conflicts with reuse capability. Transaction-level caching suffers from combinatorial path explosion, as the space of possible paths grows exponentially with contract complexity. This results in ephemeral artifacts with negligible reuse across diverse workloads~\cite{forerunner,seer}.

To assess whether these barriers can be surmounted, we analyzed Ethereum mainnet workloads and derived three critical insights. \textbf{First}, dynamic state-access operations are relatively sparse along hot paths, while fixed-cost computational instructions dominate. Since optimizing dynamic operations risks altering the gas schedule, restricting acceleration to static-cost instructions enables correctness by construction. \textbf{Second}, dependencies relevant for optimization are confined to stack operations. Capturing full memory and storage state incurs prohibitive overhead while providing negligible utility, and thus lightweight stack-only tracing suffices for effective optimization. \textbf{Third}, the top 1\% of unique frame-level paths accounts for over 70\% of total execution time, indicating that shifting granularity from transactions to call frames unlocks high cache hit rates across diverse workloads.

Guided by these insights, we present Helios, a path-driven execution accelerator built on three architectural principles. To guarantee safety, Helios employs a hybrid execution model that restricts optimization to static-cost instructions while delegating dynamic-cost operations to the native engine, preserving exact gas semantics by construction. To break the performance paradox, Helios decouples optimization from the critical path via asynchronous lightweight tracing that captures only stack-level dependencies. To maximize reuse, Helios organizes artifacts at frame-level granularity, enabling diverse transactions to composably reuse cached paths and converting ephemeral transaction-level caching into durable components.

In summary, this paper makes the following contributions:
\begin{itemize}[leftmargin=0pt, itemindent=2em, labelsep=0.5em]

\item We systematically analyze existing acceleration strategies on modern execution engines and formulate the \textit{Performance Paradox}. We identify the separation of static and dynamic costs, stack-confined dependencies, and frame-level locality as key levers to resolve this paradox.

\item We propose Helios, a novel architecture achieving correctness by construction through hybrid execution, breaking the performance paradox via asynchronous tracing, and maximizing reuse through frame-level caching.

\item We develop a high-performance engine featuring a register-based interpreter and bulk gas deduction, serving as the unified runtime for both deterministic replay and speculative execution.

\item We implement Helios on Revm and evaluate it on Ethereum mainnet workloads, demonstrating a median speedup of 6.60$\times$ over the native baseline while maintaining exact gas consistency.

\end{itemize}
