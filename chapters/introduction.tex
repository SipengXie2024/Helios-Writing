\section{Introduction}

Smart contract platforms~\cite{smart_contract_1,smart_contract_2,smart_contract_3,smart_contract_4} have extended blockchain functionality far beyond cryptocurrency transfers, enabling decentralized finance~\cite{defi}, non-fungible tokens~\cite{nft}, and on-chain governance~\cite{DAO}. At the core of this ecosystem lies the Ethereum Virtual Machine, or EVM, a shared execution layer that powers Ethereum mainnet, Layer-2 rollups, and EVM-compatible sidechains~\cite{ethereum,base,arbitrum,polygon,bsc}. Together, these systems secure assets worth tens of billions of dollars and process the majority of programmable on-chain activity~\cite{defillama}. 

They typically follow a Dissemination–Consensus–Execution pipeline~\cite{forerunner}, in which transactions are broadcast through a peer-to-peer network, ordered into blocks by a consensus protocol, and executed by the EVM on every node to update local state. Because each node must independently re-execute every transaction to verify state transitions, the cost of EVM bytecode interpretation is amplified across thousands of replicas. 

A node keeps pace with the chain only if it completes per-block execution within the block interval, and throughput is therefore bounded by the slower of block production and block execution~\cite{mtpu,morphDAG}. Consensus-layer advances have progressively shortened block intervals~\cite{hotstuff,parbft,tockcuckoo,tockowl}, shifting the bottleneck toward execution. Attempts to compensate by raising gas limits or packing more transactions per block~\cite{bnb_doc,poly_doc} only intensify execution pressure, inflating per-block latency and ultimately capping achievable throughput. EVM execution has thus become the dominant scalability constraint, particularly for contract-intensive workloads. 

From a data-management perspective, the EVM instantiates a deterministic transaction processor on every node that must sustain two workloads, namely real-time processing of incoming transactions and high-throughput replay of historical transactions for state verification and rollup proving. Because all nodes must agree on state transitions and gas metering underpins both economic consensus and DoS resistance, any viable acceleration strategy must improve execution speed while strictly preserving gas-semantic correctness and cross-replica determinism.

Achieving meaningful acceleration on modern, hyper-optimized execution engines~\cite{revm,evmone} requires overcoming three fundamental tensions. \textbf{First}, optimization conflicts with semantic preservation. Standard compiler optimizations such as instruction reordering inherently alter the observable execution trace, violating the strict gas accounting rules that underpin economic consensus~\cite{revmc,monad,evmjit,bnbjit}. A single gas discrepancy can cause nodes to diverge on state validity. Moreover, Just-In-Time (JIT) compilation introduces security vulnerabilities where maliciously crafted contracts exploit compilation overhead to mount denial-of-service attacks~\cite{JITBomb}. These constraints demand that any viable acceleration strategy preserve gas semantics by construction. \textbf{Second}, instrumentation overhead conflicts with execution latency. On sub-microsecond engines such as Revm~\cite{revm}, the cost of synchronous tracing frequently exceeds execution latency itself, creating what we term the \textit{Optimization Dilemma}~\cite{forerunner,seer}. Similarly, operation-level concurrent execution incurs synchronization costs that outweigh parallel gains~\cite{parallelEvm,evmTracer}. Any optimization blocking the critical path risks performance regression. \textbf{Third}, artifact granularity conflicts with reuse capability. Transaction-level caching faces combinatorial path explosion challenges, as the space of possible paths grows exponentially with contract complexity. This often results in ephemeral artifacts with limited reuse potential across diverse workloads~\cite{forerunner,seer}.

To assess whether these barriers can be surmounted, we analyzed Ethereum mainnet workloads and derived three critical insights. \textbf{First}, dynamic state-access operations are relatively sparse along hot paths, while fixed-cost computational instructions dominate. Since optimizing dynamic operations risks altering the gas schedule, restricting acceleration to static-cost instructions enables correctness by construction. \textbf{Second}, dependencies relevant for optimization are confined to stack operations. Capturing full memory and storage state incurs prohibitive overhead while providing negligible utility, and thus lightweight stack-only tracing suffices for effective optimization. \textbf{Third}, the top 1\% of unique frame-level paths accounts for over 70\% of total execution time, indicating that shifting granularity from transactions to call frames unlocks high cache hit rates across diverse workloads.

Guided by these insights, we present Helios, a path-driven execution accelerator built on three architectural principles. To guarantee safety, Helios employs a hybrid execution model that restricts optimization to static-cost instructions while delegating dynamic-cost operations to the native engine, preserving exact gas semantics by construction. To resolve the optimization dilemma, Helios decouples optimization from the critical path via asynchronous lightweight tracing that captures only stack-level dependencies. To maximize reuse, Helios organizes artifacts at frame-level granularity, enabling diverse transactions to composably reuse cached paths and converting ephemeral transaction-level caching into durable components.

In summary, this paper makes the following contributions:
\begin{itemize}[leftmargin=0pt, itemindent=2em, labelsep=0.5em]

\item We identify the \textit{Optimization Dilemma} on modern execution engines and propose \textbf{asynchronous lightweight tracing} that decouples trace generation from the critical path, resolving the overhead barrier without blocking execution.

\item We design \textbf{frame-level caching} with frequency-based pruning that exploits execution locality, transforming ephemeral artifacts into broadly reusable components.

\item We develop a \textbf{register-based interpreter with bulk gas deduction} that achieves 6.60$\times$ median speedup while guaranteeing gas-semantic correctness through hybrid execution of static and dynamic instructions.

\item We implement Helios on Revm and evaluate it on Ethereum mainnet, demonstrating consistent acceleration in both Replay Mode and Online Mode.

\end{itemize}
