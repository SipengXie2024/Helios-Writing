\section{Introduction}

Smart contract platforms~\cite{smart_contract_1,smart_contract_2,smart_contract_3,smart_contract_4} have extended blockchain functionality far beyond cryptocurrency transfers, enabling decentralized finance~\cite{defi}, non-fungible tokens~\cite{nft}, and on-chain governance~\cite{DAO}. At the core of this ecosystem lies the Ethereum Virtual Machine, or EVM, a shared execution layer that powers Ethereum mainnet, Layer-2 rollups, and EVM-compatible sidechains~\cite{ethereum,base,arbitrum,polygon,bsc}. Together, these systems secure assets worth tens of billions of dollars and process the majority of programmable on-chain activity~\cite{defillama}. 

They typically follow a Dissemination–Consensus–Execution pipeline~\cite{forerunner}, in which transactions are broadcast through a peer-to-peer network, ordered into blocks by a consensus protocol, and executed by the EVM on every node to update local state. Because each node must independently re-execute every transaction to verify state transitions, the cost of EVM bytecode interpretation is amplified across thousands of replicas. 

A node keeps pace with the chain only if it completes per-block execution within the block interval, and throughput is therefore bounded by the slower of block production and block execution~\cite{mtpu,morphDAG}. Consensus-layer advances have progressively shortened block intervals~\cite{hotstuff,parbft,tockcuckoo,tockowl}, shifting the bottleneck toward execution. Attempts to compensate by raising gas limits or packing more transactions per block~\cite{bnb_doc,poly_doc} only intensify execution pressure, inflating per-block latency and ultimately capping achievable throughput. EVM execution has thus become the dominant scalability constraint, particularly for contract-intensive workloads. 

From a data-management perspective, the EVM instantiates a deterministic transaction processor on every node that must sustain two workloads, namely real-time processing of incoming transactions and high-throughput replay of historical transactions for state verification and rollup proving. Because all nodes must agree on state transitions and gas metering underpins both economic consensus and DoS resistance, any viable acceleration strategy must improve execution speed while strictly preserving gas-semantic correctness and cross-replica determinism.

Achieving meaningful acceleration on modern, hyper-optimized execution engines~\cite{revm,evmone} requires overcoming three fundamental tensions. \textbf{First}, optimization conflicts with semantic preservation. Standard compiler optimizations such as instruction reordering inherently alter the observable execution trace, violating the strict gas accounting rules that underpin economic consensus~\cite{revmc,monad,evmjit,bnbjit}. A single gas discrepancy can cause nodes to diverge on state validity. Moreover, Just-In-Time (JIT) compilation introduces security vulnerabilities where maliciously crafted contracts exploit compilation overhead to mount denial-of-service attacks~\cite{JITBomb}. These constraints demand that any viable acceleration strategy preserve gas semantics by construction. \textbf{Second}, instrumentation overhead conflicts with execution latency. On sub-microsecond engines such as Revm~\cite{revm}, the cost of synchronous tracing frequently exceeds execution latency itself, creating what we term the \textit{Performance Paradox}~\cite{forerunner,seer}. Similarly, operation-level concurrent execution incurs synchronization costs that outweigh parallel gains~\cite{parallelEvm,evmTracer}. Any optimization blocking the critical path risks performance regression. \textbf{Third}, artifact granularity conflicts with reuse capability. Transaction-level caching suffers from combinatorial path explosion, as the space of possible paths grows exponentially with contract complexity. This results in ephemeral artifacts with negligible reuse across diverse workloads~\cite{forerunner,seer}.

To assess whether these barriers can be surmounted, we analyzed Ethereum mainnet workloads and derived three critical insights. \textbf{First}, dynamic state-access operations are relatively sparse along hot paths, while fixed-cost computational instructions dominate. Since optimizing dynamic operations risks altering the gas schedule, restricting acceleration to static-cost instructions enables correctness by construction. \textbf{Second}, dependencies relevant for optimization are confined to stack operations. Capturing full memory and storage state incurs prohibitive overhead while providing negligible utility, and thus lightweight stack-only tracing suffices for effective optimization. \textbf{Third}, the top 1\% of unique frame-level paths accounts for over 70\% of total execution time, indicating that shifting granularity from transactions to call frames unlocks high cache hit rates across diverse workloads.

Guided by these insights, we present Helios, a path-driven execution accelerator built on three architectural principles. To guarantee safety, Helios employs a hybrid execution model that restricts optimization to static-cost instructions while delegating dynamic-cost operations to the native engine, preserving exact gas semantics by construction. To break the performance paradox, Helios decouples optimization from the critical path via asynchronous lightweight tracing that captures only stack-level dependencies. To maximize reuse, Helios organizes artifacts at frame-level granularity, enabling diverse transactions to composably reuse cached paths and converting ephemeral transaction-level caching into durable components.

In summary, this paper makes the following contributions:
\begin{itemize}[leftmargin=0pt, itemindent=2em, labelsep=0.5em]

\item We systematically analyze existing acceleration strategies on modern execution engines and formulate the \textit{Performance Paradox}. We identify the separation of static and dynamic costs, stack-confined dependencies, and frame-level locality as key levers to resolve this paradox.

\item We propose Helios, a novel architecture achieving correctness by construction through hybrid execution, breaking the performance paradox via asynchronous tracing, and maximizing reuse through frame-level caching.

\item We develop a high-performance engine featuring a register-based interpreter and bulk gas deduction, serving as the unified runtime for both deterministic replay and speculative execution.

\item We implement Helios on Revm and evaluate it on Ethereum mainnet workloads, demonstrating a median speedup of 6.60$\times$ over the native baseline while maintaining exact gas consistency.

\end{itemize}
