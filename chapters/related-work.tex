\section{Related Work}

Research on EVM acceleration spans smart contract optimization, path-driven speculative execution, and concurrent execution. Helios targets modern high-performance interpreters such as Revm, where auxiliary overhead often dominates execution time.

\subsection{Smart Contract Optimization}

\textbf{Program Analysis.} Static analysis tools such as Slither~\cite{slither} and Rattle~\cite{rattle} generate intermediate representations for vulnerability detection and decompilation. While Rattle also lifts EVM bytecode into SSA form, it targets offline analysis without producing executable artifacts. Helios employs SSA as a dynamic executable format for immediate use by a specialized interpreter.

\textbf{Superoptimization.} Superoptimization frameworks~\cite{ebso,gasol,syrup} search for gas-minimal instruction sequences via SMT solvers~\cite{smt}. Encoding EVM semantics including memory expansion and dynamic gas costs causes exponential blowup, restricting these approaches to small basic blocks without memory side-effects.

\textbf{JIT and AOT Compilation.} JIT compilers such as Revmc, Monad, and EVM-JIT~\cite{revmc,bnbjit,evmjit,monad} translate bytecode to native code to bypass the interpreter loop. For microsecond-scale EVM transactions, code generation overhead often outweighs execution speedup. Helios instead transforms paths into an abstract graph executed by a Traced Interpreter, reducing dispatch count while retaining host-level optimizations.

\subsection{Path-driven Speculative Execution}

\textbf{Comparison with Existing Systems.} Forerunner~\cite{forerunner} generates Accelerated Programs using full-context tracing that captures stack frames, memory snapshots, and contract state. Seer~\cite{seer} employs branch prediction with state snapshots to manage dependencies. Helios addresses the artifact overhead bottleneck with lightweight asynchronous tracing that records only stack operations, achieving 9.4--16.4$\times$ compression over full-context approaches.

\textbf{Granularity and Gas Semantics.} Prior systems cache at transaction granularity, limiting reuse to identical sequences. Helios introduces frame-level caching to exploit path locality of individual contract calls, while preserving gas equivalence by restricting optimization to static-cost instructions.

\subsection{Concurrent and Parallel Execution}

\textbf{Operation-Level Concurrency.} ParallelEVM~\cite{parallelEvm} tracks data dependencies via an SSA Operation Log, enabling selective re-execution of conflicting operations. Unlike Helios, which targets single-thread path optimization, ParallelEVM focuses on concurrency control and relies on synchronous tracing with non-negligible overhead on high-performance interpreters.

\textbf{Parallel Architectures.} Other approaches include PaVM~\cite{pavm} for intra- and inter-contract parallelism, Block-STM~\cite{blockstm} for optimistic concurrency control, and MTPU~\cite{mtpu} for hardware-centric spatial-temporal scheduling.

\textbf{Orthogonality.} Helios is orthogonal to these frameworks. Its lightweight path execution engine optimizes sequential contract execution, a baseline that can be integrated into parallel systems to further maximize throughput.
