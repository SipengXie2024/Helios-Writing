\section{Related Work}

This work focuses on accelerating Ethereum Virtual Machine (EVM) execution, specifically targeting modern, high-performance interpreters such as Revm. Research in this domain can be categorized into smart contract optimization toolchains, trace-based speculative execution systems, and concurrent execution architectures.

\subsection{Smart Contract Optimization and Compilation}

Optimization in the smart contract landscape spans from static source analysis to bytecode rewriting and compilation.

\textbf{Program Analysis and Optimization.} Traditional Solidity toolchains provide static analysis capabilities that serve as a foundation for downstream optimization. Tools like Slither~\cite{slither} generate intermediate representations (SlithIR) and control flow graphs (CFG) to detect vulnerabilities. Rattle~\cite{rattle} lifts EVM bytecode into a SSA form to recover high-level control flow. While Rattle and Helios both leverage SSA to eliminate redundant stack operations, their objectives differ fundamentally. Rattle employs SSA as an intermediate representation for static analysis and decompilation, prioritizing readability without propagating changes back to the executable bytecode. In contrast, Helios utilizes SSA as a dynamic, executable format (\texttt{SsaGraph}) specifically designed for the runtime engine. The Helios optimizer operates on frame-level execution paths rather than static bytecode, generating artifacts for immediate execution acceleration via a specialized interpreter rather than for analysis.

\textbf{Superoptimization.} Superoptimization frameworks~\cite{ebso,gasol,syrup} aim to identify the optimal instruction sequence functionally equivalent to a target sequence but with minimal gas cost. While theoretically capable of producing maximally efficient code, these approaches rely on SMT solvers~\cite{smt} to verify equivalence. The operational semantics of the EVM---specifically the modeling of memory expansion, storage, and dynamic gas costs---require complex logic encodings that heavily tax SMT solvers. Consequently, the search space for equivalent programs explodes exponentially with instruction count, often necessitating strict timeouts or restricting optimization to basic blocks without memory side-effects. These constraints make superoptimization difficult to apply dynamically at runtime.

\textbf{JIT and AOT Compilation.} Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilers attempt to translate EVM bytecode into native machine code. Projects like Revmc~\cite{revmc} generate Rust code from EVM bytecode to bypass the interpreter loop. However, for the microsecond-scale transactions typical of the EVM, the overhead of runtime code generation often outweighs the execution speedup. Helios mitigates this overhead by avoiding full native compilation. Instead, it transforms execution paths into an abstract graph representation replayed by a specialized Traced Interpreter. This approach maintains the micro-architectural optimizations of the underlying host interpreter while reducing the instruction dispatch count.

\subsection{Trace-Based Speculative Execution}

As a path-driven execution engine, Helios is directly comparable to systems like Forerunner~\cite{forerunner} and Seer~\cite{seer}.

\textbf{Comparison with Existing Systems.} Forerunner applies constraint-driven speculative execution, generating "Accelerated Programs" (APs) based on transaction history. Seer employs fine-grained branch prediction and snapshots to manage state dependencies. However, these systems face limitations when applied to modern, fast interpreters due to their tracing strategy. Forerunner relies on full-context tracing, capturing stack frames, memory snapshots, and contract state. On highly optimized engines like Revm, the I/O overhead of loading these large artifacts often exceeds the execution time of the transaction itself. Helios employs \textbf{lightweight asynchronous tracing} to address this bottleneck. By recording only stack operations and minimal data dependencies, Helios achieves compression rates of 9.4$\times$ to 16.4$\times$ compared to full-context approaches, rendering online artifact management practical.

\textbf{Granularity and Gas Semantics.} Existing systems typically utilize transaction-level caching, which limits reuse to identical transaction sequences. Helios introduces \textbf{frame-level caching}, exploiting the observation that individual contract call frames exhibit high path locality even when parent transactions differ. Furthermore, prior works do not explicitly address the preservation of gas semantics during optimization. Helios guarantees gas equivalence by construction: it restricts SSA optimization to static-cost instructions while delegating all dynamic-cost operations (e.g., memory expansion, storage access) to the native EVM, ensuring the economic model remains undisturbed.

\subsection{Concurrent and Parallel Execution}

Various concurrent execution architectures address the sequential bottleneck of the EVM.

\textbf{Operation-Level Concurrency.} ParallelEVM~\cite{parallelEvm} enables operation-level concurrency by dynamically generating an SSA Operation Log to track data dependencies. This mechanism allows selective re-execution of conflicting operations rather than aborting entire transactions. While both ParallelEVM and Helios leverage SSA, their objectives differ fundamentally: ParallelEVM employs SSA for concurrency control and conflict resolution, whereas Helios utilizes it for single-thread execution path optimization. Furthermore, ParallelEVM relies on synchronous runtime tracing. Although the reported log generation overhead is approximately 4.5\%, Helios posits that on high-performance interpreters like Revm, any synchronous tracing on the critical path introduces non-negligible overhead, limiting net acceleration.

\textbf{Parallel Architectures.} Other approaches focus on architectural innovations. PaVM~\cite{pavm} supports both intra-contract and inter-contract parallelism through a specialized runtime system, though it does not explicitly address parallel determinism. Block-STM~\cite{blockstm} implements optimistic concurrency control with a collaborative scheduler to execute transaction sets in parallel. Hardware-centric solutions such as MTPU~\cite{mtpu} adopt algorithm-architecture co-design, utilizing spatial-temporal scheduling to exploit parallelism.

\textbf{Orthogonality Analysis.} Helios is orthogonal to these frameworks. Its core contribution is a lightweight, high-throughput path execution engine that optimizes the fundamental unit of computationâ€”the sequential execution of a contract path. This baseline acceleration can be integrated into parallel frameworks such as ParallelEVM, Block-STM, or PaVM to further maximize system throughput.

\subsection{Alternative Virtual Machine Environments}

The emergence of WebAssembly~\cite{wasm} (WASM) in blockchain has led to new runtime environments like DTVM~\cite{dtvm} and Wasmtime, which utilize JIT compilation and "hot-switching" mechanisms to balance startup performance with long-term execution efficiency. Helios adopts a similar philosophy for the EVM, using a dual-mode approach (Online vs. Replay) to adaptively balance the overhead of tracing against the benefits of optimized execution.