\section{Related Work}

Research on EVM acceleration can be categorized into smart contract optimization, path-driven speculative execution, and concurrent execution architectures. Helios targets modern high-performance interpreters such as Revm, where auxiliary overhead often dominates execution time.

\subsection{Smart Contract Optimization}

\textbf{Program Analysis.} Static analysis tools such as Slither~\cite{slither} and Rattle~\cite{rattle} generate intermediate representations for vulnerability detection and decompilation. Rattle lifts EVM bytecode into SSA form to recover high-level control flow. While both Rattle and Helios leverage SSA, their objectives differ: Rattle targets offline analysis without propagating changes to executable bytecode, whereas Helios employs SSA as a dynamic executable format, optimizing frame-level paths for immediate use by a specialized interpreter.

\textbf{Superoptimization.} Superoptimization frameworks~\cite{ebso,gasol,syrup} search for gas-minimal instruction sequences via SMT solvers~\cite{smt}. However, encoding EVM semantics including memory expansion and dynamic gas costs heavily taxes solvers, causing exponential blowup in the search space. These constraints restrict superoptimization to small basic blocks without memory side-effects, precluding dynamic application at runtime.

\textbf{JIT and AOT Compilation.} JIT compilers such as Revmc, Monad, and EVM-JIT~\cite{revmc,bnbjit,evmjit,monad} translate bytecode to native code to bypass the interpreter loop. However, for microsecond-scale transactions typical of the EVM, code generation overhead often outweighs execution speedup. Helios avoids full native compilation by transforming paths into an abstract graph replayed by a Traced Interpreter, reducing dispatch count while retaining host-level micro-architectural optimizations.

\subsection{Path-driven Speculative Execution}

\textbf{Comparison with Existing Systems.} Forerunner~\cite{forerunner} generates Accelerated Programs from transaction history using full-context tracing that captures stack frames, memory snapshots, and contract state. Seer~\cite{seer} employs branch prediction with state snapshots to manage dependencies. On optimized engines like Revm, the I/O cost of loading large artifacts often exceeds execution time. Helios addresses this bottleneck with lightweight asynchronous tracing that records only stack operations, achieving 9.4--16.4$\times$ compression over full-context approaches.

\textbf{Granularity and Gas Semantics.} Prior systems cache at transaction granularity, limiting reuse to identical sequences. Helios introduces frame-level caching to exploit the high path locality of individual contract calls. Furthermore, Helios preserves gas equivalence by restricting optimization to static-cost instructions and delegating dynamic-cost operations to the native engine.

\subsection{Concurrent and Parallel Execution}

\textbf{Operation-Level Concurrency.} ParallelEVM~\cite{parallelEvm} tracks data dependencies via an SSA Operation Log, enabling selective re-execution of conflicting operations rather than aborting entire transactions. While both systems leverage SSA, ParallelEVM targets concurrency control whereas Helios targets single-thread path optimization. ParallelEVM also relies on synchronous tracing, which introduces non-negligible overhead on high-performance interpreters.

\textbf{Parallel Architectures.} Other approaches include PaVM~\cite{pavm} for intra- and inter-contract parallelism, Block-STM~\cite{blockstm} for optimistic concurrency control, and MTPU~\cite{mtpu} for hardware-centric spatial-temporal scheduling.

\textbf{Orthogonality.} Helios is orthogonal to these frameworks. Its core contribution is a lightweight path execution engine that optimizes the sequential execution of contract paths, a baseline that can be integrated into parallel systems to further maximize throughput.
