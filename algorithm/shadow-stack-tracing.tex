\begin{algorithm}[!htbp]
\small
\caption{Shadow Stack Tracing}
\label{alg:shadow-stack-tracing}
\KwIn{$op$: Current EVM opcode}
\KwIn{$S_{evm}$: EVM value stack (after opcode execution)}
\KwIn{$S_{\ell}$: Shadow stack of LSNs tracking value provenance}
\KwOut{$e$: Trace log entry containing the opcode, current LSN, input dependencies, and output value}
\KwOut{Updated $S_{\ell}$}

\tcp{Extract input dependencies from shadow stack}
$D_{in} \gets []$ \\
$k \gets$ \textsc{GetInputCount}$(op)$ \\
\For{$i \gets 1$ \KwTo $k$}{
    $\ell \gets S_{\ell}$.\textsc{Pop}() \\
    $D_{in}$.\textsc{Append}$(\ell)$ \\
}

\tcp{Record output value and assign new LSN}
\eIf{$op$ produces stack output}{
    $v_{out} \gets S_{evm}$.\textsc{Top}() \\
    $\ell_{curr} \gets$ \textsc{NextLSN}() \\
    $S_{\ell}$.\textsc{Push}$(\ell_{curr})$ \\
}{
    $v_{out} \gets \bot$ \tcp*{No output, e.g., POP, JUMP}
    $\ell_{curr} \gets$ \textsc{NextLSN}() \\
}

\tcp{Handle stack manipulation instructions}
\If{$op \in \{\text{\texttt{DUP1}}, \text{\texttt{DUP2}}, \ldots, \text{\texttt{DUP16}}\}$}{
    $d \gets op - \text{\texttt{DUP1}} + 1$ \\
    $\ell_t \gets S_{\ell}[d]$ \tcp*{Peek without pop}
    $S_{\ell}$.\textsc{Push}$(\ell_t)$ \tcp*{Duplicate LSN}
}
\If{$op \in \{\text{\texttt{SWAP1}}, \text{\texttt{SWAP2}}, \ldots, \text{\texttt{SWAP16}}\}$}{
    $d \gets op - \text{\texttt{SWAP1}} + 1$ \\
    $S_{\ell}$.\textsc{Swap}$(0, d)$ \tcp*{Swap LSNs}
}

\tcp{Create log entry}
$e \gets \langle op, \ell_{curr}, D_{in}, v_{out} \rangle$ \\

\Return{$e$}

\end{algorithm}
