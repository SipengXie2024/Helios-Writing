\begin{algorithm}[t]
\caption{Traced Interpreter Execution}
\label{alg:traced-execution}
\KwIn{$\mathcal{G} = (V, E)$: Optimized SSA graph}
\KwIn{$\mathcal{C}: \mathbb{N} \to \mathbb{U}_{256}$: Constant value table}
\KwIn{$\Gamma$: Execution context (mutable)}
\KwIn{$g_{lim}$: Gas limit}
\KwOut{$\langle \Gamma, g_{used} \rangle$ or $\bot$ (fallback)}

\BlankLine

\tcp{Initialize virtual register file and gas counter}
$\mathcal{R}: \mathbb{N} \to \mathbb{U}_{256} \gets$ new Array$[|V|]$ \\
$g_{rem} \gets g_{lim}$ \tcp*{Remaining gas initialized to limit}

\BlankLine

\tcp{Execute vertices in topological order}
\ForEach{$v \in V$ in topological order}{

    \BlankLine
    $\vec{v} \gets \langle \rangle$ \tcp*{Operand vector}
    \ForEach{$\ell \in in(v)$}{
        \eIf{$\ell \in \mathcal{C}$}{
            $\vec{v} \gets \vec{v} \cdot \langle \mathcal{C}[\ell] \rangle$ \tcp*{Constant operand}
        }{
            $\vec{v} \gets \vec{v} \cdot \langle \mathcal{R}[\ell] \rangle$ \tcp*{Register operand}
        }
    }

    \BlankLine
    \tcp{Control flow guard verification}
    \If{$op(v) \in \{\textsc{Jump}, \textsc{Jumpi}\}$}{
        $pc \gets$ \textsc{ComputeTarget}$(op(v), \vec{v}, \Gamma)$ \\
        $\hat{pc} \gets target(v)$ \tcp*{Cached target from PathLog}

        \If{$pc \neq \hat{pc}$}{
            \Return{$\bot$} \tcp*{Guard violation - trigger fallback}
        }
    }

    \BlankLine
    \tcp{Chunked gas accounting at delimiters}
    \If{$op(v) \in \{\textsc{Gas}, \textsc{Return}, \textsc{Stop}, \textsc{Revert}, \textsc{Create}, \textsc{Create2}\}$}{
        $\delta_s \gets chunk(v)$ \tcp*{Accumulated static gas cost}

        \If{$g_{rem} < \delta_s$}{
            \Return{$\bot$} \tcp*{Gas anomaly - verify natively}
        }

        $g_{rem} \gets g_{rem} - \delta_s$ \\
    }

    \BlankLine
    \tcp{Execute opcode and update execution context}
    $\rho \gets$ \textsc{Exec}$(op(v), \vec{v}, \Gamma)$ \\

    \BlankLine
    \tcp{Deduct dynamic gas costs}
    \If{\textsc{IsDynamic}$(op(v))$}{
        $\delta_d \gets$ \textsc{DynamicGas}$(op(v), \vec{v}, \Gamma)$ \\

        \If{$g_{rem} < \delta_d$}{
            \Return{$\bot$} \tcp*{Out of gas}
        }

        $g_{rem} \gets g_{rem} - \delta_d$ \\
    }

    \BlankLine
    \tcp{Store result in virtual register}
    \If{$\rho \neq \epsilon$}{
        $\mathcal{R}[\ell(v)] \gets \rho$ \tcp*{Map LSN to result value}
    }

    \BlankLine
    \tcp{Check for execution termination}
    \If{$op(v) \in \{\textsc{Return}, \textsc{Stop}, \textsc{Revert}\}$}{
        \Return{$\langle \Gamma, g_{lim} - g_{rem} \rangle$} \\
    }
}

\BlankLine

\Return{$\langle \Gamma, g_{lim} - g_{rem} \rangle$}

\end{algorithm}
