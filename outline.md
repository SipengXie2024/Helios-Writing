# **Helios论文大纲（中文版）**

## **澄清说明**

基于前期充分讨论，本大纲采用以下原则：
1. **技术术语处理**：核心概念（SSA、JIT、EVM等）保留英文缩写，首次出现时附中文说明
2. **数据占位符**：使用【待填充】标记待实验验证的数值
3. **章节详细度**：保持与英文版一致的技术深度，便于直接撰写

---

## **完整论文结构**

### **标题：Helios: 一种面向超优化EVM客户端的轻量级路径驱动执行引擎**

---

### **摘要** (150-200词)

以太坊虚拟机(EVM)执行优化面临根本性矛盾：现有方案要么在现代高性能客户端中引入过高工程开销（如全量追踪日志、细粒度状态恢复），要么有很高的优化成本导致只能使用白名单技术，要么牺牲Gas计量兼容性造成激励机制冲突。本文提出**Helios**，一种轻量级路径驱动执行引擎，通过三种协同机制在代表性智能合约上实现【X】倍加速：(1) **非侵入式路径分析**，基于读集快照的异步采样，零关键路径开销；(2) **基于SSA的编译优化**，对热点执行路径应用常量折叠、死代码消除和公共子表达式消除等经典技术；(3) **寄存器式执行架构**，配合交易级乐观并发控制，消除恢复开销。在【N】百万条主网交易的评估中，Helios在归档节点同步场景实现【具体数字】倍加速，在线交易处理达到【具体数字】倍提升，同时保持100% Gas计量兼容性。

问题陈述:现有EVM优化方案的工程开销瓶颈
核心方法:轻量级路径追踪+SSA编译优化+寄存器执行
主要贡献:在revm等高性能客户端上实现X倍加速
关键结果:历史区块回放和在线交易处理的性能提升

---

### **1. 引言** (2页)

**1.1 研究动机：微秒级执行环境的挑战**
- 以太坊交易吞吐量瓶颈源于顺序EVM执行
- 现代客户端(revm)达到亚100微秒交易延迟，暴露新的优化约束：
  - 传统开销（同步、状态检查点）在此尺度下占主导
  - 涌现"最快的恢复就是不恢复"设计哲学

**1.2 现有优化范式的局限性**(在这里列出开销类型，而不具体说明方案)
- **JIT编译**(revmc, evmone)：启动开销、JIT炸弹漏洞
- **指令并行与冗余消除**(EVMTracer)：并行线程同步与上下文切换开销
- **部分指令重执行**(ParallelEVM)：全量追踪日志开销(3-5倍)
- **投机执行**(Forerunner)：缺乏历史路径学习、多路径路由复杂性
- **细粒度预测**(Seer)：复杂的检查点与恢复机制（栈和内存是全量，storage应用了journal_state是增量）造成存储开销和执行开销
- **核心观察**：高性能环境下的工程开销抵消理论收益

**1.3 Helios设计哲学：轻量级、路径驱动的优化**
- **轻量级分析**：异步采样消除关键路径开销
- **选择性优化**：通过历史学习将资源聚焦于已验证热点路径
- **激进简化**：交易级回滚优于细粒度恢复

**1.4 主要贡献**
1. 基于读集快照的非侵入式异步路径分析器(SsaInspector)
2. 带编译优化和GasChunk批处理的SSA中间表示(SsaGraph)
3. 配备乐观执行语义的寄存器式执行架构(SsaExecutor)
4. 适应动态工作负载演化的自适应缓存填充机制
5. 在【N】百万主网交易上的全面评估，展示【具体加速比】

**1.5 论文组织结构**

---

### **2. 背景与动机** (2.5页)

**2.1 EVM执行模型**
- 基于栈的架构，256位字操作
- Gas计量：静态成本 vs 动态成本
- 交易执行生命周期与状态管理(Memory, Storage, journaled_state)

**2.2 EVM优化方法分类**

**表1：EVM优化策略对比**

| 方法类别 | 代表工作 | 核心技术 | 主要开销 | Gas兼容性 |
|---------|---------|----------|---------|----------|
| JIT/AOT编译 | revmc, evmone | 原生代码生成 | 编译延迟 | 部分兼容 |
| 指令并行与冗余消除 | EVMTracer | 全量日志追踪与离线依赖分析，指令并行执行 | 线程同步/切换开销 | 部分兼容 |
| 部分指令重执行 | ParallelEVM | 执行时追踪 | 全量追踪日志 | 完全兼容 |
| 投机执行 | Forerunner | 预测+多路径 | 状态管理 | 完全兼容 |
| 细粒度预测 | Seer | SV预测+分支检查点 | 检查点存储与恢复 | 完全兼容 |
| **Helios(本文)** | - | 路径驱动+SSA | 最小化(异步) | 完全兼容 |

**2.3 性能瓶颈量化**
- EVMTracer分析：栈操作(60%指令) vs 状态访问瓶颈
- 基于revm基准的开销剖析：
  - 全量追踪日志：【待填充】%开销
  - 仅栈采样：【待填充】%开销
  - Gas计量检查：【待填充】%执行周期

<!-- **2.4 设计目标**
1. 关键路径分析开销 < 5%
2. 稳态热点路径命中率 > 80%
3. 零开销失败恢复
4. 100% Gas计量语义等价性 -->

---

### **3. Helios设计** (7页)

**3.1 系统架构概览**

```
┌─────────────────────────────────────────────────────┐
│                   交易输入                           │
└───────────────────┬─────────────────────────────────┘
                    │
         ┌──────────▼──────────┐
         │   缓存查找           │
         │ (调用签名+路径哈希)   │
         └──────┬────────┬──────┘
                │        │
         命中   │        │  未命中
                │        -------------|
    ┌───────────▼─┐                ┌──▼──────────────┐
    │SsaExecutor  │                │ 原生Revm执行     │
    │(乐观执行)    │ -- Guard失效-->│                 │
    └──┬──────────┘                └────┬────────────┘
       │                                │
    成功                                │ 收集读集
       │                            ┌───▼──────────────┐
       │                            │ 异步分析          │
       │                            │  (SsaInspector)  │
       │                            └───┬──────────────┘
       │                                |
       │  ┌────────────────────┐        |
       │  │  回退：原生Revm     | <-------
       │  │  重新执行           │
       │  └───┬────────────────┘
       │      │
       │  ┌───▼──────────────┐
       │  │  SSA转换         │
       │  │  + 编译优化      │
       │  │  (SsaGraph)      │
       │  └───┬──────────────┘
       │      │
       │  ┌───▼──────────────┐
       │  │ 缓存填充         │
       │  │  (GraphStore)    │
       │  └──────────────────┘
       │
   ┌───▼────────┐
   │ 交易结果    │
   └────────────┘
```

**3.2 SsaInspector：异步非侵入式路径分析器**

**3.2.1 基于读集的分析协议**
- 执行流程：原生revm完成 → 提取读集 → 快照状态 → 产生异步分析器
- 读集组成：存储槽位、内存区域、调用目标
- 状态快照机制：写时复制隔离journaled_state

**3.2.2 轻量级依赖采样**
- Inspector钩子：`step()/step_end()`, `call/create()`, `call/create_end()`拦截点
- 栈操作追踪：操作数依赖关系，无需全量状态日志
- 对JUMP,JUMPI记录jump constraint
- 记录Gas Chunk
  - 观察：EVM Gas = 静态(操作码固有) + 动态(状态依赖)
  - 批处理策略：聚合连续静态Gas成本
    ```
    传统：gas_check(); ADD; gas_check(); MUL; gas_check();
    GasChunk：gas_check(ADD成本 + MUL成本); ADD; MUL;
    ```
  - 兼容性保证：动态Gas指令触发立即检查
- 嵌套调用帧管理：逐帧哈希累积，特别介绍call/create系列需要在end处回调记录shadow_stack

**3.2.3 路径签名生成**
- 调用签名：`keccak256(代码哈希 || 函数选择器)`
- 执行路径哈希：FNV-1a滚动哈希，覆盖`[PC, opcode, 跳转目标]`元组
- 两级索引：
  ```
  调用签名 → [执行路径哈希₁, ..., 执行路径哈希ₙ]
  执行路径哈希 → 优化图
  ```

**3.2.4 健康路径过滤**
- 目标：以`STOP`、`RETURN`、`REVERT`终止的路径
- 原理：OOG/异常路径缺乏复用价值且导致存储爆炸

**3.3 SsaGraph：基于SSA的优化中间表示**

**3.3.1 SSA图构建**
- 节点边数据结构，如何从日志信息构建图

**3.3.2 编译优化套件**
- **常量折叠**：编译期求值确定性操作
- **死代码消除**：移除未使用中间结果
- **公共子表达式消除**：去重冗余计算

**3.4 GraphStore：持久化路径缓存**

**3.4.1 存储模式**
- 键：`(调用签名, 执行路径哈希)`
- 值：序列化SsaGraph + 元数据(访问频率、最后使用时间戳)

**3.4.2 缓存淘汰策略**
- 在线模式：固定容量LRU/LFU(如1万条目)
- 归档模式：LevelDB持久化存储

<!-- **3.4.3 并发访问控制** -->
<!-- - 读密集工作负载优化：读者优先RwLock -->
- 缓存预热策略：从历史区块数据预填充

**3.5 SsaExecutor：寄存器式执行引擎**

**3.5.1 寄存器堆架构**
- 设计：基于数组的32字节寄存器槽
- 分配策略：每个SSA值分配一个寄存器(朴素分配)
- 合理性论证：
  1. CSE确保值复用无需重复计算
  2. Gas限制约束路径复杂度 → 寄存器数量有界
  3. 论证附加的空间开销可控：统计*多数合约*寄存器数量
  <!-- 3. 空间-时间权衡：【待填充】KB内存换取【待填充】倍加速 -->

**3.5.2 状态管理复用**
- 内存：委托给revm的`SharedMemory`
- 存储：利用revm的`journaled_state`及快照语义
- 调用帧：复用revm原生调用栈管理

**3.5.3 控制流正确性保障**
- 跳转约束：预计算目标验证
  ```
  if 实际跳转目标 ≠ 预期跳转目标:
      中止执行()
  ```

**3.6 交易级乐观执行**

**3.6.1 "零恢复开销"哲学**
- **核心洞察**：30-60微秒交易延迟下，细粒度恢复开销 > 回滚成本
- 成本分析：
  ```
  细粒度恢复：检查点+同步+部分重放 ≈ 【待填充】微秒 (可以 mock 一下)
  完全回滚：中止+原生重执行 ≈ 【待填充】微秒 (< 恢复开销)
  ```

**3.6.2 回退机制**
- 触发条件：乐观执行期间任何guard违规
- 处理动作：立即中止 + 丢弃所有中间状态
- 重执行：委托给原生revm解释器

**3.6.3 设计空间探索：竞争并行**
- 替代方案：SSA执行器与原生revm并发运行，采用首个成功结果
- 实验发现：【待填充】%更慢，原因：
  1. 线程同步开销(自旋锁/原子操作)
  2. 资源竞争(L1/L2缓存颠簸)
  3. 尾延迟放大(P99：【待填充】微秒 vs 【待填充】微秒)
  <!-- 这些怎么测? -->

**3.7 自适应缓存填充**

**3.7.1 学习触发条件**
- 冷启动：首次执行新`调用签名`
- 缓存失效：Guard违规表明路径偏离

**3.7.2 后台分析工作流**
1. 回退执行完成 → 提取读集快照
2. 产生隔离状态副本的异步分析器线程
3. 分析器启用SsaInspector执行交易重放
4. 生成SsaGraph → 持久化到GraphStore

**3.7.3 系统演化动态**
- 冷启动惩罚：【待填充】%交易初始触发回退
- 稳态收敛：【待填充】区块后命中率达【待填充】%
- 自适应韧性：系统自动从状态变更中学习新路径

---

### **4. 实现** (1.5页) 
<!-- 或许并不需要 -->
**4.1 开发环境**
- 基础：基于Rust的revm客户端(版本【X.Y.Z】)
- Inspector接口扩展：栈依赖追踪的自定义钩子
- SSA库：自定义实现

**4.2 关键实现细节**
- FNV-1a哈希：执行期间增量计算(零拷贝)
- 寄存器堆：连续内存分配优化缓存局部性
- GraphStore序列化：Bincode格式配合LZ4压缩
- 并发性：Tokio异步运行时用于后台分析线程

**4.3 工程挑战**
- 嵌套调用路径拼接：帧感知哈希链接
- Gas精度：避免浮点运算确保确定性计量
- 大合约处理：寄存器分配上界 = 【待填充】

**4.4 代码复杂度指标**
- Helios核心：约【待填充】行代码
- 与revm集成：约【待填充】行修改
- 测试覆盖率：【待填充】%行覆盖率

---

## **Section 5: Evaluation（最终精简版）**

---

### **5.1 实验设置**

**数据集**：以太坊主网区块【范围】（【待填充】M交易），微基准：Uniswap V2/ERC20/WETH

**基线**：revm、revmc、ParallelEVM（追踪开销对比）

**指标**：执行时间、Opcode数、追踪开销、缓存命中率、内存占用

**平台**：【CPU/RAM】，Ubuntu【版本】，Rust【版本】，cargo-flamegraph

---

### **5.2 微基准测试**

**5.2.1 合约级性能分解**

**表5：路径分析开销**

| 合约 | 追踪方法 | 相对revm时间 |
|------|---------|------------|
| **Uniswap V2** | 无追踪（revm） | 1.0× |
| | Helios异步栈采样 | 1.5× |
| | ParallelEVM全量日志 | 【3-5】× |
| **ERC20** | 无追踪 | 1.0× |
| | Helios | 1.5× |
| | ParallelEVM | 【3-5】× |
| **WETH** | 无追踪 | 1.0× |
| | Helios | 1.5× |
| | ParallelEVM | 【3-5】× |

**表6：SSA编译优化效果**

| 合约 | revm原始 | 常量折叠 | DCE | CSE | Helios优化后 | Gas计算次数 |
|------|---------|---------|-----|-----|------------| ------------|
| **Uniswap V2** | 【待填充】 | -【a】 | -【b】 | -【c】 | 【待填充】 | 【待填充】|
| **ERC20** | 【待填充】 | -【d】 | -【e】 | -【f】 | 【待填充】 |【待填充】|
| **WETH** | 【待填充】 | -【g】 | -【h】 | -【i】 | 【待填充】 | 【待填充】|

**表7：执行性能**

| 合约 | 系统 | 时间(μs) | 加速比 |
|------|------|---------|--------|
| **Uniswap V2** | revm | 【待填充】 | 1.0× |
| | Helios | 【待填充】 | ~2.0× |
| | revmc | 【待填充】 | 【待填充】× |
| **ERC20** | revm | 【待填充】 | 1.0× |
| | Helios | 【待填充】 | 【待填充】× |
| | revmc | 【待填充】 | 【待填充】× |
| **WETH** | revm | 【待填充】 | 1.0× |
| | Helios | 【待填充】 | 【待填充】× |
| | revmc | 【待填充】 | 【待填充】× |

---

**5.2.2 执行成本异构性分析**

**表8：热点指令开销（Uniswap V2）**

| 指令 | 次数 | revm(ns) | Helios(ns) | 额外开销来源 |
|------|-----|---------|-----------|------------|
| **KECCAK256** | 【待填充】 | 【待填充】 | 【待填充】 | 图访问+寄存器解析 |
| **SLOAD** | 【待填充】 | 【待填充】 | 【待填充】 | 图访问 |
| **SSTORE** | 【待填充】 | 【待填充】 | 【待填充】 | 图访问+寄存器读 |
| **MSTORE** | 【待填充】 | 【待填充】 | 【待填充】 | 寄存器读 |
| **ADD/MUL** | 【待填充】 | 【待填充】 | 【待填充】 | 寄存器读写 |
| **PUSH/DUP** | 【待填充】 | 【待填充】 | - | 被优化消除 |

**图4**：KECCAK256 Flamegraph对比

**归因**：Helios在昂贵操作上引入图访问（【X】%）和寄存器解析（【Y】%）开销，但通过消除低成本栈操作实现净加速。成本异构性解释了opcode减少与时间节省的非线性关系。

指令:keccak256/mstore/sstore..
原生：栈操作、gas操作、指令本身开销
Helios: 图访问、gas操作、寄存器取、指令本身开销、寄存器写
分别包含：次数+平均开销
mock一下即可

---

### **5.3 设计选择验证**

**表9：执行策略对比**

| 策略 | 平均(μs) | P99(μs) |
|------|---------|---------|
| 顺序（Helios） | 【待填充】 | 【待填充】 |
| 竞争并行 | 【待填充】 | 【待填充】 |

**归因**：并行劣化源于spinlock竞争、cache coherency、尾延迟放大。

---

### **5.4 端到端性能**

**5.4.1 归档节点同步**

**表2：区块批量处理**

| 系统 | 平均(μs) | TPS | 加速比 |
|------|---------|-----|--------|
| revm | 【待填充】 | 【待填充】 | 1.0× |
| Helios | 【待填充】 | 【待填充】 | 【待填充】× |

**图1**：累积加速比（0-12M区块）

**图2**：存储开销对比（Snapshot vs GraphStore）

**图3**：寄存器需求分布（中位【待填充】，P99【待填充】）

**内存开销**：中位【待填充】KB，P99【待填充】KB

---

**5.4.2 在线交易处理**

**表3：在线性能**

| 系统 | 平均(μs) | TPS | 加速比 |
|------|---------|-----|--------|
| revm | 【待填充】 | 【待填充】 | 1.0× |
| Helios | 【待填充】 | 【待填充】 | 【待填充】× |

**表4：乐观执行演化**

| 指标 | 冷启动(0-1K) | 稳态(10M-12M) |
|------|------------|--------------|
| 命中率 | 【待填充】% | 【待填充】% |
| 回退率 | 【待填充】% | 【待填充】% |
| 回退惩罚(μs) | 【待填充】 | 【待填充】 |

**图5**：路径访问频率分布（Zipf，α=【待填充】）

**图6**：命中率收敛曲线

**图7**：命中率 vs 缓存容量（拐点【待填充】K）

**表5：淘汰策略对比**

| 策略 | 命中率 | 淘汰开销(μs) |
|------|-------|------------|
| LRU | 【待填充】% | 【待填充】 |
| LFU | 【待填充】% | 【待填充】 |
| ARC | 【待填充】% | 【待填充】 |

---


### **6. 讨论** (2页)

**6.1 设计权衡**

**6.1.1 朴素寄存器分配 vs 复杂复用**
- 权衡：简单性和速度 vs 内存效率
- 收支平衡分析：【待填充】μs节省/交易 > 【待填充】KB内存成本

**6.1.2 交易级回滚 vs 细粒度恢复**
- 上下文依赖最优性：微秒级执行有利于激进回滚
- 反例：毫秒级虚拟机(JVM, V8)受益于增量恢复

**6.1.3 异步 vs 内联分析**
- 同步分析：更低回退惩罚但更高关键路径开销
- 选择策略：优化常见情况(缓存命中)而牺牲罕见情况(冷启动)

**6.2 相对于现有工作的定位**

**6.2.1 为何不采用纯JIT？**
- 编译延迟摊销需要长期运行进程
- EVM交易是短暂的(30-60μs执行时间)
- Helios：零启动开销的路径驱动预编译

**6.2.2 为何不做指令级并行？**
- 理论ILP(EVMTracer)：1.9×加速
- 实际实现成本：线程同步 > 微秒级ILP收益
- Helios：通过编译期并行性(CSE, DCE)的顺序执行

**6.2.3 为何路径驱动？**
- 实证观察：80%执行集中于20%路径(图5)
- 资源分配：优化已证明热点路径，忽略冷/异常路径

**6.3 局限性与未来工作**

**6.3.1 冷启动性能**
- 当前惩罚：首次执行【待填充】×减速
- 缓解措施：静态分析辅助预热(未来工作)

**6.3.2 罕见情况下的路径爆炸**
- 高控制流多样性合约(如动态调度器)
- 潜在解决方案：混合静态+动态分析

**6.3.3 与并行执行框架集成**
- Helios作为BlockSTM/ParallelEVM的执行基底
- 开放问题：如何结合路径驱动优化与投机并行？

---

### **7. 相关工作** (2页)
*(您选择后续单独撰写，此处仅列结构)*

**7.1 EVM优化技术**
- JIT/AOT编译：revmc, evmone, EVMJIT
- 程序特化：Forerunner

**7.2 区块链并行执行**
- 乐观并行：ParallelEVM, Seer, BlockSTM
- 依赖分析：EVMTracer, Rattle

**7.3 动态编译与追踪**
- 基于追踪的JIT：TraceMonkey, PyPy, LuaJIT
- 配置文件引导优化：LLVM PGO, GraalVM

**7.4 虚拟机优化**
- 寄存器 vs 栈式架构：JVM, WebAssembly
- 内联缓存与热点检测：V8, SpiderMonkey

---

### **8. 结论** (0.5页)

本文提出Helios，一种轻量级路径驱动执行引擎，挑战EVM优化的传统智慧。通过采用针对微秒级执行环境定制的"零恢复开销"哲学，Helios通过异步分析、基于SSA的编译和寄存器式执行实现【具体加速比】倍加速。在【N】百万主网交易的评估验证了路径驱动优化的有效性，同时保持100% Gas计量兼容性。Helios为区块链执行引擎提供新范式：选择性、自适应、工程开销感知的大规模优化。

---

## **附录** (可选)

**A. SSA转换算法伪代码**

**B. 跳转约束验证逻辑**

**C. 补充实验数据**
- 完整合约覆盖率分析
- 长期运行稳定性测试

---

## **预估篇幅**
- 正文：14-16页(ASPLOS双栏格式)
- 参考文献：2-3页
- 附录：1-2页